---
- name: Build and Install Custom Pop!_OS Kernel
  hosts:  "{{ _host_ | default('localhost') }}"
  become: yes
  vars:
    work_dir: "/tmp/kernel-build"
    kernel_source_dir: "{{ work_dir }}/linux/kernel"
    pop_os_kernel_repo: "https://github.com/pop-os/linux.git"
    pop_os_kernel_branch: "master_jammy"
    # We'll determine these dynamically during playbook execution
    debug_mode: true

  tasks:
    - name: Install required build dependencies
      apt:
        name:
          - git
          - build-essential
          - libncurses-dev
          - bison
          - flex
          - libssl-dev
          - libelf-dev
          - gcc
          - make
          - dwarves
          - zstd
          - bc
          - rsync
          - dkms
          - debhelper
          - debhelper-compat
          - fakeroot
          - kernel-wedge
          - devscripts
          - ccache
        state: present
        update_cache: yes

    - name: Ensure Pop!_OS kernel source is present and up to date
      git:
        repo: "{{ pop_os_kernel_repo }}"
        dest: "{{ kernel_source_dir }}"
        version: "{{ pop_os_kernel_branch }}"
        depth: 1
        update: yes
        force: yes

    - name: Get kernel version from Makefile
      command: make --no-print-directory -C {{ kernel_source_dir }} kernelversion
      register: kernelversion_cmd
      changed_when: false

    - name: Save kernel version
      command: |
        echo {{ kernelversion_cmd.stdout }} > /var/custom_kernel_version.txt

    - name: Show kernel version
      ansible.builtin.debug:
        msg: "Kernel Version: {{ kernelversion_cmd.stdout }}" 

    - name: Get CPU information
      command: cat /proc/cpuinfo
      register: cpu_info
      changed_when: false

    - name: Create custom kernel config
      blockinfile:
        path: "{{ kernel_source_dir }}/.config"
        create: yes
        block: |
          # General setup
          CONFIG_64BIT=y
          CONFIG_SMP=y
          # Disable 32-bit support
          CONFIG_COMPAT=n
          CONFIG_X86_32=n
          
          # CPU-specific optimizations (will be detected during build)
          CONFIG_GENERIC_CPU=n
          CONFIG_MNATIVE=y
          
          # Default CPU governor
          CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
          CONFIG_CPU_FREQ_GOV_POWERSAVE=y
          
          # Power management
          CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y
          #CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE=y
          CONFIG_CPU_FREQ_GOV_ONDEMAND=y
          CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
          CONFIG_INTEL_IDLE=y
          CONFIG_CPU_IDLE=y
          CONFIG_INTEL_PSTATE=y
          CONFIG_ACPI_CPPC_CPUFREQ=y
          
          # NVIDIA hybrid laptops (ensure seamless PRIME / suspend)
          CONFIG_DRM_SIMPLEDRM=n
          CONFIG_DRM_NOUVEAU=m

          # Disable unnecessary features
          CONFIG_FB_BOOT_VESA_SUPPORT=n
          CONFIG_FRAMEBUFFER_CONSOLE=n
          CONFIG_LOGO=n
          CONFIG_CHROME_PLATFORMS=n
          
          # Disable security mitigations for performance
          CONFIG_RETPOLINE=n
          CONFIG_SPECULATION_BARRIER=n
          CONFIG_PAGE_TABLE_ISOLATION=n
          CONFIG_KAISER=n
          CONFIG_RANDOMIZE_BASE=n
          CONFIG_RANDOMIZE_MEMORY=n
          CONFIG_STACKPROTECTOR=n
          CONFIG_STACKPROTECTOR_STRONG=n
          CONFIG_VMAP_STACK=n
          CONFIG_STRICT_KERNEL_RWX=n
          CONFIG_STRICT_MODULE_RWX=n
          CONFIG_SECURITY_DMESG_RESTRICT=n
          CONFIG_STATIC_USERMODEHELPER=n
          
          # Enable modern features
          CONFIG_PREEMPT=y
          CONFIG_HIGH_RES_TIMERS=y
          CONFIG_NO_HZ_FULL=y
          CONFIG_RCU_NOCB_CPU=y
          CONFIG_NUMA=y
          CONFIG_TRANSPARENT_HUGEPAGE=y
          
          # Power saving features
          CONFIG_PM_AUTOSLEEP=y
          CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
          CONFIG_PM_WAKELOCKS=y
          CONFIG_ENERGY_MODEL=y
          
          #
          # FANCY STUFF
          #
          
          # Filesystem optimizations
          CONFIG_BTRFS_FS=y
          CONFIG_BTRFS_FS_POSIX_ACL=y
          CONFIG_BTRFS_FS_CHECK_INTEGRITY=n
          CONFIG_BTRFS_FS_RUN_SANITY_TESTS=n
          CONFIG_BTRFS_FS_REF_VERIFY=n
          CONFIG_BTRFS_FS_COMPRESSION_ZSTD=y

          # Zswap configuration with LZ4
          CONFIG_ZSWAP=y
          CONFIG_ZSWAP_COMPRESSOR_DEFAULT_LZ4=y
          CONFIG_ZSWAP_ZPOOL_DEFAULT_ZBUD=y
          CONFIG_ZSWAP_DEFAULT_ON=y
          CONFIG_CRYPTO_LZ4=y
          CONFIG_CRYPTO_LZ4HC=y
          CONFIG_Z3FOLD=y
          CONFIG_ZBUD=y
          
          # Multigenerational LRU
          CONFIG_LRU_GEN=y
          CONFIG_LRU_GEN_ENABLED=y
          CONFIG_LRU_GEN_STATS=y
          
          # Debugging / unnecessary features OFF
          CONFIG_DEBUG_KERNEL=n
          CONFIG_PM_DEBUG=n
          CONFIG_PM_ADVANCED_DEBUG=n
          CONFIG_KASAN=n
          CONFIG_KCOV=n
          CONFIG_KUNIT=n
    - name: Copy current kernel config as base
      shell: |
        if [ -f /boot/config-$(uname -r) ]; then
          cp /boot/config-$(uname -r) {{ kernel_source_dir }}/.config
        else
          make defconfig
        fi
      args:
        chdir: "{{ kernel_source_dir }}"

    - name: Configure kernel
      shell: |
        make olddefconfig
        if [ "{{ debug_mode }}" = "true" ]; then
          echo "Running make menuconfig for manual verification"
          make menuconfig
        fi
      args:
        chdir: "{{ kernel_source_dir }}"

    - name: Check if kernel image .deb exists for current version
      stat:
        path: "{{ work_dir }}/linux/linux-image-{{ kernelversion_cmd.stdout }}+_{{ kernelversion_cmd.stdout }}-1_amd64.deb"
      register: kernel_image_deb

    - name: Kernel .deb files already exists 
      ansible.builtin.debug:
        msg: "deb files already exist: {{ work_dir }}/linux/linux-image-{{ kernelversion_cmd.stdout }}+_{{ kernelversion_cmd.stdout }}-1_amd64.deb"
      when: kernel_image_deb.stat.exists

    - name: Build kernel
      shell: |
        export DEB_BUILD_OPTIONS='nocheck parallel=$(nproc)'
        export DPKG_FLAGS='-d'
        export CC="ccache gcc"

        # make -j$(nproc) clean
        make -j$(($(nproc) * 2)) bindeb-pkg KDEB_PKGVERSION=$(make kernelversion)-1
      args:
        chdir: "{{ kernel_source_dir }}"
      register: build_result
      when: not kernel_image_deb.stat.exists

    - name: Install custom kernel and headers
      apt:
        deb: "{{ item }}"
        state: present
      with_fileglob:
        - "{{ work_dir }}/linux/linux-*-{{ kernelversion_cmd.stdout }}+_{{ kernelversion_cmd.stdout }}-1_amd64.deb"
      tags: ["install"]

    - name: Verify installed kernel image exists
      stat:
        path: "/boot/vmlinuz-{{ kernelversion_cmd.stdout }}+"
      register: kernel_image_stat
      tags: ["install", "verify"]

    - name: Fail if kernel image is missing
      fail:
        msg: "Kernel image /boot/vmlinuz-{{ kernelversion_cmd.stdout }}+ is missing!"
      when: not kernel_image_stat.stat.exists
      tags: ["install", "verify"]

    - name: Verify kernel modules directory exists and is not empty
      shell: |
        test -d /lib/modules/{{ kernelversion_cmd.stdout }}+ && [ "$(find /lib/modules/{{ kernelversion_cmd.stdout }}+ -type f -name '*.ko*' | wc -l)" -gt 0 ]
      register: modules_dir_check
      changed_when: false
      failed_when: modules_dir_check.rc != 0
      tags: ["install", "verify"]

    - name: Ensure systemd-boot loader directories exist
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      with_items:
        - /boot/efi/loader
        - /boot/efi/loader/entries
      tags: ["install", "bootloader"]

    - name: copy custom kernel to EFI
      shell: |
        # Get our custom kernel version from saved file
        kernel_version="{{ kernelversion_cmd.stdout }}" 

        # Copy kernel and initrd to EFI partition
        mkdir -p /boot/efi/EFI/Pop_OS-${kernel_version}
        cp /boot/vmlinuz-${kernel_version}+ /boot/efi/EFI/Pop_OS-${kernel_version}/vmlinuz.efi
        cp /boot/initrd.img-${kernel_version}+ /boot/efi/EFI/Pop_OS-${kernel_version}/initrd.img
        
        test -s /boot/efi/EFI/Pop_OS-${kernel_version}/vmlinuz.efi
        test -s /boot/efi/EFI/Pop_OS-${kernel_version}/initrd.img
      register: efi_copy_result
      changed_when: true
      failed_when: efi_copy_result.rc != 0

    - name: Create boot entry for custom kernel
      shell: |
        # Get our custom kernel version from saved file
        kernel_version="{{ kernelversion_cmd.stdout }}"
        
        # Get current kernel cmdline options
        current_options=$(cat /proc/cmdline | sed 's/BOOT_IMAGE=[^ ]* //g')
                
        # Create loader entry
        cat > /boot/efi/loader/entries/pop-os-custom-${kernel_version}.conf << EOF
        title Pop!_OS (Custom ${kernel_version})
        linux /EFI/Pop_OS-${kernel_version}/vmlinuz.efi
        initrd /EFI/Pop_OS-${kernel_version}/initrd.img
        options ${current_options} nvidia-drm.modeset=1 i915.enable_psr=1 pcie_aspm.policy=powersupersave
        EOF
                
        echo "Created boot entry for kernel ${kernel_version}"
      args:
        chdir: "{{ kernel_source_dir }}"
      tags: ["install", "bootloader"]

    - name: Configure loader timeout
      blockinfile:
        path: /boot/efi/loader/loader.conf
        create: yes
        marker: "# {mark} ANSIBLE MANAGED BLOCK - CUSTOM KERNEL SETTINGS"
        block: |
          timeout 3
          console-mode max
          editor no
      tags: ["install", "bootloader"]

    - name: Update kernelstub configuration
      shell: |
        # Configure kernelstub to use our custom kernel
        kernel_version="{{ kernelversion_cmd.stdout }}"
        
        kernelstub --verbose --manage-only \
          --esp-path /boot/efi \
          --kernel-path /boot/vmlinuz-${kernel_version}+ \
          --initrd-path /boot/initrd.img-${kernel_version}+ \
          --loader-path /EFI/Pop_OS-${kernel_version}/vmlinuz.efi
      args:
        chdir: "{{ kernel_source_dir }}"
      when: false
      tags: ["make-default"]

    - name: Set custom kernel as default boot entry
      blockinfile:
        path: /boot/efi/loader/loader.conf
        marker: "# {mark} ANSIBLE MANAGED BLOCK - DEFAULT KERNEL SETTING"
        block: |
          default pop-os-custom.conf
      when: false
      tags: ["make-default"]